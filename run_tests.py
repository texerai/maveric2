import os
import argparse
import sys


#-------------------------
# Constants.
#-------------------------
SCRIPT_1 = "./scripts/bin-to-hex.py"
SCRIPT_2 = "./scripts/hex-to-mem.py"

AM_TEST_DIR = "./test/tests/list/list-am.txt"
RV_ARCH_TEST_DIR = "./test/tests/list/list-rv-arch-test.txt"
RV_TESTS_DIR = "./test/tests/list/list-rv-tests.txt"
TEST_DIR = "./test/tests/list/list.txt"

MEMORY_FILE = "./rtl/mem_simulated.sv"
TB_FILE     = "./test/tb/tb_test_env.cpp"
RESULT_FILE = "./results/result.txt"
TEST_ENV_FILE = "./rtl/test_env.sv"
DCACHE_FILE   = "./rtl/dcache.sv"

TEST_AM = []
TEST_RV_ARCH= []
TEST_RV = []
TEST = {}



#-------------------------
# Prepare tests.
#-------------------------
with open(AM_TEST_DIR, 'r') as file_in:
    for line in file_in:
                TEST_AM.append(line.strip())

with open(RV_ARCH_TEST_DIR, 'r') as file_in:
    for line in file_in:
                TEST_RV_ARCH.append(line.strip())

with open(RV_TESTS_DIR, 'r') as file_in:
    for line in file_in:
                TEST_RV.append(line.strip())

with open(TEST_DIR, 'r') as file_in:
    for line in file_in:
            # Strip newlines and whitespace
            line = line.strip()
            # Check if the line contains a colon
            if ':' in line:
                # Split the line at the first colon
                parts = line.split(':', 1)
                key = parts[0].strip()
                directory = parts[1].strip()
                TEST[key] = directory
            else:
                print("No colon found in the line.")



#-------------------------
# Commands.
#-------------------------
COMPILE_C_COMMAND = "gcc -c -o ./check.o ./test/tb/check.c"
COMPILE_LOG_COMMAND = "gcc -c -o ./log_trace.o ./test/tb/log_trace.c"
VERILATE_COMMAND_START = "verilator --assert -I./rtl --Wall --cc ./rtl/test_env.sv "
VERILATE_COMMAND_END = " --exe ./test/tb/tb_test_env.cpp ./test/tb/check.c ./test/tb/log_trace.c"

MAKE_COMMAND = "make -C obj_dir -f Vtest_env.mk"
SAVE_COMMAND = '''./obj_dir/Vtest_env | awk '
    /PC/ {
        print >> "res.txt"; next;
    }
    {
        print; print >> "res.txt";
    }' '''
CLEAN_SINGLE = "rm -r ./obj_dir check.o log_trace.o"
CLEAN_TESTS  = "rm -r ./test/tests/dis-asm ./test/tests/instr"
CLEAN_RESULT = "rm ./results/result.txt"

COV_MERGE = "verilator_coverage --write merged.dat cov/*"
COV_ANNOTATE = "verilator_coverage --annotate coverage_annotated/ merged.dat"


#-------------------------
# Help messages.
#-------------------------
HELP_MSG_SCRIPT_DESCRIPTION = "Utility script to automate test runs on the MAVERIC CORE 2.0 processor."
HELP_MSG_ALL_DESCRIPTION = "Run all tests."
HELP_MSG_LIST_DESCRIPTION = "Print the list of all available tests."
HELP_MSG_SINGLE_DESCRIPTION = "Run a single test. Format: -s <test_name>. Use -l to list available tests."
HELP_MSG_GROUP_DESCRIPTION = "Run a group of tests. Format: -g <test_group>. Available groups: am, rv-tests, rv-arch-test."
HELP_MSG_CLEAN_DESCRIPTION = "Clean the work directory by deleting all files generated during the test run."
HELP_MSG_TRACE_DESCRIPTION = "Generate a waveform. Works only with the -s flag."
HELP_MSG_VARYING_DESCRIPTION = "Run all tests across multiple cache sizes, ranging from 128 B to 8 KB."
HELP_MSG_COVERAGE_ALL_DESCRIPTION = "Generate coverage reports for both line and toggle coverage."
HELP_MSG_COVERAGE_LINE_DESCRIPTION = "Generate coverage report for line coverage."
HELP_MSG_COVERAGE_TOGGLE_DESCRIPTION = "Generate coverage report for toggle coverage."
HELP_MSG_PREP_FOR_COMMIT_DESCRIPTION = "Removes autogenerated files and restores autoupdated files to prepare for git commit."


#-------------------------
# Clean commands.
#-------------------------

# Clean before start.
def clean_before():
    os.system(CLEAN_RESULT)
    with open (RESULT_FILE, 'w') as file_out:
        file_out.write("")


# Clean after the run.
def clean_single():
    os.system(CLEAN_SINGLE)

# Clean after the run.
def clean():
    os.system(CLEAN_TESTS)


#-------------------------
# Compile commands
#-------------------------

# Compile single test.
def compile_single(test, block_size=512, set_count=16, gen_wave=False, gen_coverage=False):
    modify_testbench(not gen_wave, not gen_coverage)
    modify_memory(TEST[test])
    os.system(COMPILE_C_COMMAND)
    os.system(COMPILE_LOG_COMMAND)
    command = VERILATE_COMMAND_START
    if gen_coverage:
        command += " --coverage"
    if gen_wave:
        command += " --trace"

    command += VERILATE_COMMAND_END 
    os.system(command)
    os.system(MAKE_COMMAND)
    save_result(test, block_size, set_count, gen_coverage)
    clean_single()


# Compile group of tests.
def compile_group(group, gen_coverage=False):
    if group == 'am':
        for test in TEST_AM:
            compile_single(test, gen_coverage = gen_coverage)
    elif group == 'rv-arch-test':
        for test in TEST_RV_ARCH:
            compile_single(test, gen_coverage = gen_coverage)
    elif group == 'rv-tests':
        for test in TEST_RV:
            compile_single(test, gen_coverage = gen_coverage)
    else:
        print("Unrecognized test group")


# Compile all tests.
def compile_all(block_size=512, set_count=16, gen_coverage=False):
    for key in TEST.keys():
        compile_single(key, block_size=block_size, set_count=set_count, gen_coverage = gen_coverage)


# Compile all tests with varying cache sizes.
def compile_varying_cache(gen_coverage=False):
     block_size = 128
     while block_size <= 1024:
          set_count = 2
          while set_count <= 16:
               modify_cache_size(block_size, set_count)
               with open (RESULT_FILE, 'r') as file_in:
                    lines = file_in.readlines()
           
               old_lines = []
               for line in lines:
                   old_lines.append(line)
           
               with open(RESULT_FILE, 'w') as file_out:
                    file_out.writelines(old_lines)
                    message = "\n\nCACHE_LINE_WIDTH: " +  str(block_size) + " bits, SET_COUNT: " + str(set_count) + "\n"
                    file_out.write(message)   

               # compile_single("am-add", False)
               compile_all(block_size, set_count, gen_coverage)
               set_count *= 2
          block_size *= 2


# Print command.
def print_all_tests():
    for key in TEST.keys():
        print(key)



#-------------------------
# Helper functions.
#-------------------------

# Modify the cache size in cache HDL file.
def modify_cache_size(block_size, set_count):
    with open ( TEST_ENV_FILE, 'r' ) as file_in:
        lines = file_in.readlines()

    new_lines = []
    parameter_found = False
    for line in lines:
        if 'parameter' in line:
            parameter_found =True
        
        if parameter_found:
            if 'BLOCK_WIDTH' in line:
                new_line = line[:31] + str(block_size)
                new_lines.append(new_line)
                new_lines.append("\n")
                parameter_found = False
            else:
                new_lines.append(line)
        else:
            new_lines.append(line)

    with open (TEST_ENV_FILE, 'w') as file_out:
        file_out.writelines(new_lines)


    with open ( DCACHE_FILE, 'r' ) as file_in:
        lines = file_in.readlines()

    new_lines = []
    parameter_found = False
    for line in lines:
        if 'parameter' in line:
            parameter_found =True
        
        if parameter_found:
            if 'SET_COUNT' in line:
                new_line = line[:27] + str(set_count)
                new_lines.append(new_line)
                new_lines.append("\n")
                parameter_found = False
            else:
                new_lines.append(line)
        else:
            new_lines.append(line)

    with open (DCACHE_FILE, 'w') as file_out:
        file_out.writelines(new_lines)


# Save test results.
def save_result(test, block_size, set_count, gen_coverage):
    os.system(SAVE_COMMAND)

    with open ('res.txt', 'r') as file_in:
        lines_res = file_in.readlines()

    lines_log_trace = lines_res[:-3]
    LOG_FILE = "./log_trace/" + test + "-log-trace.log"

    os.system("rm " + LOG_FILE)
    with open (LOG_FILE, 'w') as file_out:
        file_out.writelines(lines_log_trace)

    unit_test_res = lines_res[-3]

    with open (RESULT_FILE, 'r') as file_in:
        lines = file_in.readlines()

    old_lines = []
    for line in lines:
        old_lines.append(line)

    with open(RESULT_FILE, 'w') as file_out:
        file_out.writelines(old_lines)
        file_out.write(f'{test + ": ":<29}')
        file_out.write(unit_test_res)
        if "pass" not in unit_test_res.lower():
            os.system("rm res.txt")
            print(f"\nEror: Test {test} failed")
            print("Terminating test suite execution.")
            sys.exit(1)


    os.system("rm res.txt")
    if gen_coverage:
        os.system(f"mv coverage.dat cov/coverage_{test}_{block_size}_{set_count}.dat")


# Modify memory file used for test.
def modify_memory(mem_directory):
    with open (MEMORY_FILE, 'r') as file_in:
        lines = file_in.readlines()
    new_lines = []
    for line in lines:
         if '`define' in line:
            new_line = '`define PATH_TO_MEM ' + "\"" +mem_directory + "\""
            new_lines.append(new_line)
            new_lines.append("\n")
         else:
            new_lines.append(line)
    with open (MEMORY_FILE, 'w') as file_out:
        file_out.writelines(new_lines)


# Modify testbench file.
def modify_testbench(comment_trace, comment_coverage):
    with open (TB_FILE, 'r') as file_in:
        lines = file_in.readlines()
    new_lines = []
    for line in lines:
        if 'trace' in line:
            if '//' in line:
                if comment_trace:
                    new_lines.append(line)
                else:
                    new_line = "  " + line[2:]
                    new_lines.append(new_line)
            else:
                if comment_trace:
                    new_line = '//' + line[2:]
                    new_lines.append(new_line)
                else:
                    new_lines.append(line)
        elif 'VerilatedCov' in line:
            if '//' in line:
                if comment_coverage:
                    new_lines.append(line)
                else:
                    new_line = "  " + line[2:]
                    new_lines.append(new_line)
            else:
                if comment_coverage:
                    new_line = '//' + line[2:]
                    new_lines.append(new_line)
                else:
                    new_lines.append(line)
        else:
            new_lines.append(line)

    with open (TB_FILE, 'w') as file_out:
        file_out.writelines(new_lines)


# Write initial note.
def initial_note():
    with open(RESULT_FILE, 'w') as file_out:
        message = []
        message.append("NOTE 1: ILLEGAL INSTRUCTION REFERS TO INSTRUCTIONS THAT WERE NOT (YET) IMPLEMENTED IN MAVERIC CORE 2.0 PROCESSOR. THE SYSTEM REGOGNIZES THOSE INSTRUCTIONS AS ILLEGAL.\n")
        message.append("THE LIST INCLUDES, BUT IS NOT LIMITED TO, MUL, DIV, AND FENCE INSTRUCTIONS.\n")
        message.append("\nNOTE 2: THE LOW LEVELS OF BRANCH PREDICTION ACCURACY IN GIVEN TESTS ARE ASSOCIATED WITH VERY HIGH NUMBER OF BRANCHES THAT ARE TAKEN ONLY ONCE IN RV-ARCH-TEST AND\n")
        message.append("WITH A SMALL TOTAL NUMBER OF BRANCHES IN RV-TESTS.\n")
        for i in range(4):
            file_out.write(message[i])


def parse_arguments():
    parser = argparse.ArgumentParser(description=HELP_MSG_SCRIPT_DESCRIPTION)
    parser.add_argument('-a', '--compile-all',
                        action='store_true',
                        help=HELP_MSG_ALL_DESCRIPTION)
    parser.add_argument('-l', '--list-tests',
                        action='store_true',
                        help=HELP_MSG_LIST_DESCRIPTION)

    parser.add_argument('-s', '--compile-single',
                        type=str,
                        metavar='test_name',
                        help=HELP_MSG_SINGLE_DESCRIPTION)

    parser.add_argument('-g', '--compile-group',
                        type=str,
                        metavar='test_group',
                        help=HELP_MSG_GROUP_DESCRIPTION)

    parser.add_argument('-c', '--clean',
                        action='store_true',
                        help=HELP_MSG_CLEAN_DESCRIPTION)

    parser.add_argument('-t', '--trace',
                        action='store_true',
                        help=HELP_MSG_TRACE_DESCRIPTION)

    parser.add_argument('-v', '--compile-varying-cache',
                        action='store_true',
                        help=HELP_MSG_VARYING_DESCRIPTION)

    parser.add_argument('-ca', '--coverage-all',
                        action='store_true',
                        help=HELP_MSG_COVERAGE_ALL_DESCRIPTION)

    parser.add_argument('-cl', '--coverage-line',
                        action='store_true',
                        help=HELP_MSG_COVERAGE_LINE_DESCRIPTION)

    parser.add_argument('-ct', '--coverage-toggle',
                        action='store_true',
                        help=HELP_MSG_COVERAGE_TOGGLE_DESCRIPTION)
    parser.add_argument('-p', '--prepare-for-commit',
                        action='store_true',
                        help=HELP_MSG_PREP_FOR_COMMIT_DESCRIPTION)

    return parser.parse_args()


    return parser.parse_args()


def prepare_tests():
    os.system("python3 " + SCRIPT_1)
    os.system("python3 " + SCRIPT_2)
    os.system("mkdir log_trace")

def prep():
    prepare_tests()
    clean_before()
    initial_note()

def prepare_for_commit():
    os.system("git restore ./results/result.txt")
    os.system("git restore ./rtl/mem_simulated.sv")
    os.system("rm -r log_trace")
    os.system("rm ./waveform.vcd")
    clean_single()
    clean()

def main():
    args = parse_arguments()

    if args.coverage_all:
        os.system ("mkdir cov")
  
    if args.compile_single:
        prep()
        compile_single(args.compile_single, 512, 16, args.trace, args.coverage_all)
        clean()
    elif args.list_tests:
        print_all_tests()
    elif args.compile_all:
        prep()
        compile_all(gen_coverage=args.coverage_all)
        clean()
    elif args.compile_group:
        prep()
        compile_group(args.compile_group, args.coverage_all)
        clean()
    elif args.compile_varying_cache:
        prep()
        compile_varying_cache(args.coverage_all)
        clean()
    elif args.prepare_for_commit:
        prepare_for_commit()
    elif args.clean:
        clean_single()
        clean()
    else:
        print("Invalid arguments")

    if args.coverage_all:
        os.system(COV_MERGE)
        os.system(COV_ANNOTATE + " | tee -a ./coverage_results.txt")
        os.system("rm -r ./cov")

main()
